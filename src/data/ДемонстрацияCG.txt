Пустой объект занимает 16 байт памяти.

В моём примере, в классе User мы имеем 4 поля: int age, String name, boolean working и char gender.
При User user = new User(23, "Pol", true, 'M') создаётся объект размером:
16 + 4(размер int) + (32 + (3 * 2)) + 1(размер boolean) + 2(размер char) = 65
Так как 65 не делиться на 8, то округляем в бОльшую сторону и получаем 72 байта.

Создадим второй объект класса User
User user01 = new User(68, "Vladimir Putin", true, 'M')
Объект user01 будет занимать:
16 + 4 + (32 + (14 * 2)) + 1 + 2 = 75 байт
Округляем в бОльшую сторону и получим 80 байт.

Вместе два объекта будут занимать 72 + 80 = 152 байта памяти.

В расчёте размера String число 36 означает:
8 + // object header used by the VM
8 + // 64-bit reference to char array (value)
8 + string.length() * 2 + // character array itself (object header + 16-bit chars)
4 + // offset integer
4 + // count integer
4 + // cached hash code

При выставлении ключей -Xmx4m программа будет самостоятельно вызывать сборщик мусора. Создавая на каждой итерации
новый объект класса User мы заполняли Eden. Когда Eden заполнился, все бессылочные объекты удалились и в survivor
перешёл только один объект (текущий), далее Eden снова заполняется, GC убирает все объекты без ссылок и переводит в
survivor еще один объект (текущий, он же имеет ссылку) и в survivor становиться уже два объекта класса User. Так
происходит до тех пор, пока не заполниться survivor0, и уже GC удаляет безссылочные объекты из survivor0. И переводит
один текущий объект User в survivor1. Такие операции происходят на всём протяжении цикла в 10000 итераций. До old gen
не доходит ни один объект класса User. Потому что он не успевает "дозреть", age не успевает вырасти до определенного
значения.